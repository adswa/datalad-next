"""Validate DataLad datasets"""

from pathlib import PurePath

from datalad.support.exceptions import NoDatasetFound

from .base import (
    Constraint,
    DatasetDerived,
)


class EnsureDataset(Constraint):
    """Ensure a absent/present `Dataset` from any path or Dataset instance

    Regardless of the nature of the input (`Dataset` instance or local path)
    a resulting instance (if it can be created) is optionally tested for
    absence or presence on the local file system.

    .. warning::
       When a `Dataset` instances is create from a path input by this
       constraint, the instances receives a `.auto_instance_from_path`
       attribute to indicate that the original argument was not a
       `Dataset` instance. This is important, because resolution of
       relative paths within DataLad commands differs depending on the
       type of the `dataset` argument.

       The `resolve_path()` function is patched by datalad-next to honor
       to behavior, based on the presence of this attribute.

       However, DataLad uses quasi-singleton `Dataset` instances for each
       unique path (flyweight-pattern). This means that the assigned
       attribute is common to any and all `Dataset` "instances" within
       a Python session (within the lifetime of a `Dataset` instance).
       This implies that passing dataset instances and relative paths
       to internal command calls can lead to undesired path resolution.

       Example: A command is called with a path value for its `dataset`
       argument and a relative path to another. When calling
       `resolve_path(ds=)` with the dataset instance generated by this
       constraint, relative paths will be interpreted relative to the
       current working directory. In any subsequent command call via a
       dataset method of this `Dataset` instance, any internal call to
       `resolve_path()` will continue to interpret relative paths as
       relative to the current working directory, and not as relative
       to the dataset root.

       This can only be prevented by passing absolute paths (as returned
       by `resolve_path()`) to any internal command call.

       Only `Dataset` instances exhibit this behavior. `Repo` instances,
       like `GitRepo` or `AnnexRepo` do not. For the latter, passing
       relative paths to their methods is more common, or even standard
       behavior.
    """
    def __init__(self, installed: bool = None, purpose: str = None):
        """
        Parameters
        ----------
        installed: bool, optional
          If given, a dataset will be verified to be installed or not.
          Otherwise the installation-state will not be inspected.
        purpose: str, optional
          If given, will be used in generated error messages to communicate
          why a dataset is required (to exist)
        """
        self._installed = installed
        self._purpose = purpose
        super().__init__()

    def __call__(self, value) -> DatasetDerived:
        # good-enough test to recognize a dataset instance cheaply
        if hasattr(value, 'repo') and hasattr(value, 'pathobj'):
            if self._installed is not None:
                is_installed = value.is_installed()
                if self._installed and not is_installed:
                    # for uniformity with require_dataset() below, use
                    # this custom exception
                    raise NoDatasetFound(f'{value} is not installed')
                elif not self._installed and is_installed:
                    raise ValueError(f'{value} already exists locally')
            return value
        elif not isinstance(value, (str, PurePath)):
            raise TypeError(f"Cannot create Dataset from {type(value)}")

        from datalad.distribution.dataset import require_dataset
        ds = require_dataset(
            value,
            check_installed=self._installed is True,
            purpose=self._purpose,
        )
        if self._installed is False and ds.is_installed():
            raise ValueError(f'{ds} already exists locally')
        # following the proposal https://github.com/datalad/datalad/issues/7168
        # we mark the dataset instance for resolve_path()
        ds.auto_instance_from_path = value
        return ds

    def short_description(self) -> str:
        return "(path to) {}Dataset".format(
            'an existing ' if self._installed is True
            else 'a non-existing ' if self._installed is False else 'a ')
